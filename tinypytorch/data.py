# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_data.ipynb.

# %% auto 0
__all__ = ['get_local_data', 'Dataset', 'Sampler', 'collate', 'DataLoader']

# %% ../nbs/01_data.ipynb 3
from torch import tensor
import torch

from fastcore.utils import *
from .core import *

import matplotlib.pyplot as plt

# %% ../nbs/01_data.ipynb 6
import pickle

# %% ../nbs/01_data.ipynb 7
def get_local_data():
    f = open('mnist.pkl', 'rb')
    ((x_train, y_train), (x_valid, y_valid), _) = pickle.load(f, encoding='latin-1')
    x_train,y_train,x_valid,y_valid = map(tensor, (x_train,y_train,x_valid,y_valid))
    return x_train, y_train, x_valid, y_valid

# %% ../nbs/01_data.ipynb 10
class Dataset:
    def __init__(self, x: 'input', y: 'output'):
        self.x, self.y = x, y
    
    def __len__(self):
        return len(self.x)
    
    def __getitem__(self, i):
        return self.x[i], self.y[i]

# %% ../nbs/01_data.ipynb 15
class Sampler():
    def __init__(self,
                 ds, # dataset
                 bs, # batch size
                 shuffle=False): # shuffle or not?
        self.n, self.bs, self.shuffle = len(ds), bs, shuffle
    
    def __iter__(self):
        self.idxs = torch.randperm(self.n) if self.shuffle else torch.arange(self.n)
        for i in range(0, self.n, self.bs):
            yield self.idxs[i:i+self.bs]

# %% ../nbs/01_data.ipynb 27
def collate(b):
    xs, ys = zip(*b)
    return torch.stack(xs), torch.stack(ys)

# %% ../nbs/01_data.ipynb 28
class DataLoader():
    def __init__(self, ds, sampler, collate_fn=collate):
        self.ds = ds
        self.sampler = sampler
        self.collate_fn = collate
    
    def __iter__(self):
        for s in self.sampler:
            yield self.collate_fn([self.ds[i] for i in s])
